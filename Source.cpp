#include <opencv2/opencv.hpp>
#include <opencv2/highgui/highgui.hpp>

#include "EnclosedArea.h"
#include <iostream>

using namespace cv;
using namespace std;

struct gridTile
{
	Point ip;
	TileType stone;
};

int main()
{
	Mat bgframe;
	Mat frame;
	vector<double> ip_x;
	vector<double> ip_y;
	VideoCapture cap;
	// open the default camera, use something different from 0 otherwise;
	// Check VideoCapture documentation.
	if (!cap.open(0))
		return 0;
	for (;;)
	{
		ip_x.clear();
		ip_y.clear();
		cap >> bgframe;
		if (bgframe.empty()) break; // end of video stream
		//imwrite("emptyboard2.jpg", frame);

		frame = bgframe.clone();
		Mat src = frame.clone();
		Mat dst;// , cdst;
		cvtColor(src, dst, CV_RGB2GRAY);
		Canny(dst, dst, 50, 200, 3);
		//adaptiveThreshold(src, dst, 255, ADAPTIVE_THRESH_GAUSSIAN_C, CV_THRESH_BINARY, 15, 11);
		imshow("edge", dst);
		//cvtColor(dst, cdst, CV_GRAY2BGR);

		vector<Vec2f> lines;
		// detect lines
		HoughLines(dst, lines, 1, CV_PI / 180, 200, 0, 0);
		int count = 0;

		Point pt1, pt2;
		vector<double> p_x, p_y;
		// draw lines
		for (size_t i = 0; i < lines.size(); i++)
		{
			float rho = lines[i][0], theta = lines[i][1];
			if (theta == 0)
			{
				double a = cos(theta), b = sin(theta);
				double x0 = a*rho, y0 = b*rho;
				p_x.push_back(x0);
			}
			if (theta > CV_PI / 180 * 85 && theta < CV_PI / 180 * 95)
			{
				double a = cos(theta), b = sin(theta);
				double x0 = a*rho, y0 = b*rho;
				p_y.push_back(y0);
			}
		}

		sort(p_x.begin(), p_x.end());
		double previous_x = 0;
		for (int i = 0; i < p_x.size(); i++)
		{
			if ((p_x[i] - previous_x) > 10)
			{
				Point pt1, pt2;
				pt1.x = p_x[i];
				pt1.y = 1000;
				pt2.x = p_x[i];
				pt2.y = -1000;
				//line(cdst, pt1, pt2, Scalar(0, 0, 255), 1, CV_AA);
				ip_x.push_back(p_x[i]);
			}
			previous_x = p_x[i];
		}

		while (ip_x.size() > 19)
		{
			if (abs(ip_x[0] - src.cols / 2) > abs(ip_x[ip_x.size() - 1] - src.cols / 2))
			{
				ip_x.erase(ip_x.begin());
			}
			else
			{
				ip_x.pop_back();
			}
		}

		for (int i = 0; i < ip_x.size(); i++)
		{
			Point pt1, pt2;
			pt1.x = ip_x[i];
			pt1.y = 1000;
			pt2.x = ip_x[i];
			pt2.y = -1000;
			line(frame, pt1, pt2, Scalar(0, 255, 0), 1, CV_AA);
count++;
		}

		sort(p_y.begin(), p_y.end());
		double previous_y = 0;
		for (int i = 0; i < p_y.size(); i++)
		{
			cout << "py= " << p_y[i] << endl;
			if ((p_y[i] - previous_y) > 10)
			{
				cout << "py_i= " << p_y[i] << endl;
				Point pt1, pt2;
				pt1.x = -1000;
				pt1.y = p_y[i];
				pt2.x = 1000;
				pt2.y = p_y[i];
				//line(cdst, pt1, pt2, Scalar(0, 0, 255), 1, CV_AA);
				ip_y.push_back(p_y[i]);
			}
			previous_y = p_y[i];
		}

		while (ip_y.size() > 19)
		{
			if (abs(ip_y[0] - src.rows / 2) > abs(ip_y[ip_y.size() - 1] - src.rows / 2))
			{
				ip_y.erase(ip_y.begin());
			}
			else
			{
				ip_y.pop_back();
			}
		}
		for (int i = 0; i < ip_y.size(); i++)
		{
			cout << ip_y[i] << endl;
			Point pt1, pt2;
			pt1.x = -1000;
			pt1.y = ip_y[i];
			pt2.x = 1000;
			pt2.y = ip_y[i];
			line(frame, pt1, pt2, Scalar(0, 255, 0), 1, CV_AA);
			count++;
		}

		imshow("this is you, smile! :)", frame);
		if (waitKey(10) == 27) break; // stop capturing by pressing ESC 
	}
	// the camera will be closed automatically upon exit
	// cap.close();
	bgframe = imread("emptyboard3.jpg");

	//imshow("gridlines", frame);

	Mat finishedFrame;
	for (;;)
	{
		cap >> finishedFrame;
		if (finishedFrame.empty()) break; // end of video stream
								  //imwrite("emptyboard2.jpg", frame);

		Mat temp = finishedFrame.clone();
		addWeighted(temp, 0.5, bgframe, 0.5, 0, temp);
		imshow("this is you, smile! :)", temp);
		if (waitKey(10) == 27) break; // stop capturing by pressing ESC 
	}

	finishedFrame = imread("stones.jpg");

	// Global variables
	Mat frame1, frame2; //current frame
	Mat fgMaskMOG2; //fg mask fg mask generated by MOG method
	Ptr<BackgroundSubtractor> pMOG2; //MOG2 Background subtractor

	pMOG2 = createBackgroundSubtractorMOG2();

	frame1 = bgframe.clone();
	cvtColor(frame1, frame1, CV_RGB2GRAY);
	GaussianBlur(frame1, frame1, Size(5, 5), 0, 0);
	//	adaptiveThreshold(frame1, frame1, 255, ADAPTIVE_THRESH_GAUSSIAN_C, CV_THRESH_BINARY, 15, 11);
	imshow("emptyboard1", frame1);

	frame2 = finishedFrame.clone();
	cvtColor(frame2, frame2, CV_RGB2GRAY);
	GaussianBlur(frame2, frame2, Size(5, 5), 0, 0);
	//	adaptiveThreshold(frame2, frame2, 255, ADAPTIVE_THRESH_GAUSSIAN_C, CV_THRESH_BINARY, 15, 11);
	imshow("result1", frame2);

	//update the background model
	pMOG2->apply(frame1, fgMaskMOG2);
	//update the background model
	pMOG2->apply(frame2, fgMaskMOG2);

	medianBlur(fgMaskMOG2, fgMaskMOG2, 5);

	imshow("FG Mask MOG2", fgMaskMOG2);


	vector<vector<gridTile>> tiles();
	for (int i = 0; i < ip_x.size(); i++)
	{
		for (int j = 0; j < ip_y.size(); j++)
		{
			gridTile myTile = gridTile();
			myTile.ip = Point(ip_x[i], ip_y[j]);
			int xBoundLeft = static_cast<int>( ip_x[i] - 3);
			int xBoundRight = xBoundLeft + 6;
			int yBoundUp = static_cast<int>(ip_y[j] - 3);
			int yBoundDown = yBoundUp + 6;
			int mean = 0;
			for (int x = xBoundLeft; x < xBoundRight; x++)
			{
				for (int y = yBoundUp; y < yBoundDown; y++)
				{
					mean += fgMaskMOG2.;
				}
			}
		}
	}

	waitKey(0);
	return 0; 
}

