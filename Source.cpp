#include <opencv2/opencv.hpp>
#include <opencv2/highgui/highgui.hpp>

#include <iostream>

using namespace cv;
using namespace std;

// Global variables
Mat frame1, frame2; //current frame
Mat fgMaskMOG2; //fg mask fg mask generated by MOG method
Ptr<BackgroundSubtractor> pMOG2; //MOG2 Background subtractor

int main()
{
	Mat src = imread("emptyboard.jpg");
	cvtColor(src, src, CV_RGB2GRAY);
	Mat dst, cdst;
	Canny(src, dst, 50, 200, 3);
	//adaptiveThreshold(src, dst, 255, ADAPTIVE_THRESH_GAUSSIAN_C, CV_THRESH_BINARY, 15, 11);
	imshow("edge", dst);
	cvtColor(dst, cdst, CV_GRAY2BGR);

	vector<Vec2f> lines;
	// detect lines
	HoughLines(dst, lines, 1, CV_PI / 180, 200, 0, 0);
	int count = 0;

	Point pt1, pt2;
	vector<double> p_x, p_y;
	// draw lines
	for (size_t i = 0; i < lines.size(); i++)
	{
		float rho = lines[i][0], theta = lines[i][1];
		if (theta == 0)
		{
			double a = cos(theta), b = sin(theta);
			double x0 = a*rho, y0 = b*rho;
			p_x.push_back(x0);
		}
		if (theta > CV_PI / 180 *85 && theta < CV_PI / 180 * 95)
		{
			double a = cos(theta), b = sin(theta);
			double x0 = a*rho, y0 = b*rho;
			p_y.push_back(y0);
		}
	}

	sort(p_x.begin(), p_x.end());
	double previous_x = 0;
	vector<double> ip_x;
	for (int i = 0; i < p_x.size(); i++)
	{
		if ((p_x[i] - previous_x) > 10)
		{
			Point pt1, pt2;
			pt1.x = p_x[i];
			pt1.y = 1000;
			pt2.x = p_x[i];
			pt2.y = -1000;
			//line(cdst, pt1, pt2, Scalar(0, 0, 255), 1, CV_AA);
			ip_x.push_back(p_x[i]);
		}
		previous_x = p_x[i];
	}

	vector<double> g_ip_x;
	for (int i = 1; i < ip_x.size() - 1; i++)
	{
		g_ip_x.push_back(ip_x[i]);
	}

	for (int i = 0; i < g_ip_x.size(); i++)
	{
		Point pt1, pt2;
		pt1.x = g_ip_x[i];
		pt1.y = 1000;
		pt2.x = g_ip_x[i];
		pt2.y = -1000;
		line(cdst, pt1, pt2, Scalar(0, 255, 0), 1, CV_AA);
		count++;
	}

	sort(p_y.begin(), p_y.end());
	double previous_y = 0;
	vector<double> ip_y;
	for (int i = 0; i < p_y.size(); i++)
	{
		cout << "py= " << p_y[i] << endl;
		if ((p_y[i] - previous_y) > 10)
		{
			cout << "py_i= " << p_y[i] << endl;
			Point pt1, pt2;
			pt1.x = -1000;
			pt1.y = p_y[i];
			pt2.x = 1000;
			pt2.y = p_y[i];
			//line(cdst, pt1, pt2, Scalar(0, 0, 255), 1, CV_AA);
			ip_y.push_back(p_y[i]);
		}
		previous_y = p_y[i];
	}

	vector<double> g_ip_y;
	int firstG_y;
	if (ip_y.size() == 20)
	{
		firstG_y = 0;
	}
	else
	{
		firstG_y = 1;
	}

	for (int i = firstG_y; i < ip_y.size() - 1; i++)
	{
		g_ip_y.push_back(ip_y[i]);
	}

	for (int i = 0; i < g_ip_y.size(); i++)
	{
		cout << g_ip_y[i] << endl;
		Point pt1, pt2;
		pt1.x = -1000;
		pt1.y = g_ip_y[i];
		pt2.x = 1000;
		pt2.y = g_ip_y[i];
		line(cdst, pt1, pt2, Scalar(0, 255, 0), 1, CV_AA);
		count++;
	}

/*	if (ip_x.size() == 21 && ip_y.size() == 21)
	{

	}*/

	cout << "line count= " << count << endl;

	imshow("source", src);
	imshow("detected lines", cdst);

/*	pMOG2 = createBackgroundSubtractorMOG2();

	string firstFrameFileName = "emptyboard.jpg";
	string secondFrameFileName = "result.jpg";

	frame1 = imread(firstFrameFileName);
	cvtColor(frame1, frame1, CV_RGB2GRAY);
	Canny(frame1, frame1, 50, 200, 3);
//	adaptiveThreshold(frame1, frame1, 255, ADAPTIVE_THRESH_GAUSSIAN_C, CV_THRESH_BINARY, 15, 11);
	imshow("emptyboard", frame1);

	Mat cdst;
	cvtColor(frame1, cdst, CV_GRAY2BGR);

	vector<Vec2f> lines;
	// detect lines
	HoughLines(frame1, lines, 1, CV_PI / 180, 150, 0, 0);

	// draw lines
	for (size_t i = 0; i < lines.size(); i++)
	{
		float rho = lines[i][0], theta = lines[i][1];
		Point pt1, pt2;
		double a = cos(theta), b = sin(theta);
		double x0 = a*rho, y0 = b*rho;
		pt1.x = cvRound(x0 + 1000 * (-b));
		pt1.y = cvRound(y0 + 1000 * (a));
		pt2.x = cvRound(x0 - 1000 * (-b));
		pt2.y = cvRound(y0 - 1000 * (a));
		line(cdst, pt1, pt2, Scalar(0, 0, 255), 3, CV_AA);
	}

	imshow("detected lines", cdst);

	frame2 = imread(secondFrameFileName);
	cvtColor(frame2, frame2, CV_RGB2GRAY);
//	adaptiveThreshold(frame2, frame2, 255, ADAPTIVE_THRESH_GAUSSIAN_C, CV_THRESH_BINARY, 15, 11);
	imshow("result", frame2);
	*/

/*	if (frame1.empty()) {
		//error in opening the first image
		cerr << "Unable to open first image frame: " << firstFrameFileName << endl;
		exit(EXIT_FAILURE);
	}
	if (frame2.empty()) {
		//error in opening the next image in the sequence
		cerr << "Unable to open image frame: " << secondFrameFileName << endl;
		exit(EXIT_FAILURE);
	}

	//update the background model
	pMOG2->apply(frame1, fgMaskMOG2);
	//update the background model
	pMOG2->apply(frame2, fgMaskMOG2);

	//show the current frame and the fg masks
	imshow("Frame", frame2);
	imshow("FG Mask MOG2", fgMaskMOG2);

	medianBlur(fgMaskMOG2, fgMaskMOG2, 5);
	imshow("FG Mask MOG2", fgMaskMOG2);

	threshold(fgMaskMOG2, fgMaskMOG2, 0, 255, CV_THRESH_BINARY | CV_THRESH_OTSU);
	imshow("FG Mask MOG2", fgMaskMOG2);

	int erosion_type = MORPH_ELLIPSE;
	int erosion_size = 1;

	Mat element = getStructuringElement(erosion_type,
		Size(2 * erosion_size + 1, 2 * erosion_size + 1),
		Point(erosion_size, erosion_size));

	/// Apply the erosion operation
	erode(fgMaskMOG2, fgMaskMOG2, element);
	imshow("eroded fg", fgMaskMOG2); */

	waitKey(0);

	return EXIT_SUCCESS; 

/*	VideoCapture cap(0); // open the default camera
	if (!cap.isOpened())  // check if we succeeded
		return -1;

	Mat frame, result;
	pMOG2 = createBackgroundSubtractorMOG2();

	for (;;)
	{
		cap >> frame; // get a new frame from camera
		imshow("original", frame);
		imwrite("emptyboard1.jpg", frame);
		pMOG2->apply(frame, fgMaskMOG2);
		imshow("fg", fgMaskMOG2);
		cvtColor(frame, result, CV_RGB2GRAY);
		GaussianBlur(result, result, Size(7,7), 0, 0);
		adaptiveThreshold(result, result, 255, ADAPTIVE_THRESH_GAUSSIAN_C, CV_THRESH_BINARY, 11, 7);
		imshow("frame", result); 
		if (waitKey(30) >= 0) break;
	}
	// the camera will be deinitialized automatically in VideoCapture destructor
	return 0;*/
}

