#include <opencv2/opencv.hpp>
#include <opencv2/highgui/highgui.hpp>

#include "GoBoard.h"
#include <iostream>

using namespace cv;
using namespace std;

struct gridTile
{
	Point ip;
	TileType stone;
};

int main()
{
	Mat bgframe;
	Mat frame;
	vector<double> ip_x;
	vector<double> ip_y;
	VideoCapture cap;
	// open the default camera, use something different from 0 otherwise;
	// Check VideoCapture documentation.
	if (!cap.open(0))
		return 0;
	for (;;)
	{
		ip_x.clear();
		ip_y.clear();
		//cap >> bgframe;
		bgframe = imread("emptyboard5.jpg");
		if (bgframe.empty()) break; // end of video stream
		//imwrite("emptyboard2.jpg", frame);

		frame = bgframe.clone();
		Mat src = frame.clone();
		Mat dst;// , cdst;
		cvtColor(src, dst, CV_RGB2GRAY);
		Canny(dst, dst, 100, 200, 3);
		//adaptiveThreshold(src, dst, 255, ADAPTIVE_THRESH_GAUSSIAN_C, CV_THRESH_BINARY, 15, 11);
		imshow("edge", dst);
		//cvtColor(dst, cdst, CV_GRAY2BGR);

		//display crosshair for placement assistance
		line(frame, Point(frame.cols / 2 + 20, frame.rows / 2), Point(frame.cols / 2 - 20, frame.rows / 2), Scalar(0, 0, 255));
		line(frame, Point(frame.cols / 2, frame.rows / 2 + 20), Point(frame.cols / 2, frame.rows / 2 - 20), Scalar(0, 0, 255));

		vector<Vec2f> lines;
		// detect lines
		HoughLines(dst, lines, 1, CV_PI / 180, 180, 0, 0);

		Point pt1, pt2;
		vector<double> p_x, p_y;
		// draw lines
		for (size_t i = 0; i < lines.size(); i++)
		{
			float rho = lines[i][0], theta = lines[i][1];
			if (theta == 0)
			{
				double a = cos(theta), b = sin(theta);
				double x0 = a*rho, y0 = b*rho;
				p_x.push_back(x0);
			}
			if (theta > CV_PI / 180 * 85 && theta < CV_PI / 180 * 95)
			{
				double a = cos(theta), b = sin(theta);
				double x0 = a*rho, y0 = b*rho;
				p_y.push_back(y0);
			}
		}

		sort(p_x.begin(), p_x.end());
		double previous_x = 0;
		for (int i = 0; i < p_x.size(); i++)
		{
			if ((p_x[i] - previous_x) > 10)
			{
				Point pt1, pt2;
				pt1.x = p_x[i];
				pt1.y = 1000;
				pt2.x = p_x[i];
				pt2.y = -1000;
				//line(cdst, pt1, pt2, Scalar(0, 0, 255), 1, CV_AA);
				ip_x.push_back(p_x[i]);
			}
			previous_x = p_x[i];
		}

		while (ip_x.size() > 19)
		{
			if (abs(ip_x[0] - src.cols / 2) > abs(ip_x[ip_x.size() - 1] - src.cols / 2))
			{
				ip_x.erase(ip_x.begin());
			}
			else
			{
				ip_x.pop_back();
			}
		}

		for (int i = 0; i < ip_x.size(); i++)
		{
			Point pt1, pt2;
			pt1.x = ip_x[i];
			pt1.y = 1000;
			pt2.x = ip_x[i];
			pt2.y = -1000;
			line(frame, pt1, pt2, Scalar(0, 255, 0), 1, CV_AA);
		}

		sort(p_y.begin(), p_y.end());
		double previous_y = 0;
		for (int i = 0; i < p_y.size(); i++)
		{
			cout << "py= " << p_y[i] << endl;
			if ((p_y[i] - previous_y) > 10)
			{
				cout << "py_i= " << p_y[i] << endl;
				Point pt1, pt2;
				pt1.x = -1000;
				pt1.y = p_y[i];
				pt2.x = 1000;
				pt2.y = p_y[i];
				//line(cdst, pt1, pt2, Scalar(0, 0, 255), 1, CV_AA);
				ip_y.push_back(p_y[i]);
			}
			previous_y = p_y[i];
		}

		while (ip_y.size() > 19)
		{
			if (abs(ip_y[0] - src.rows / 2) > abs(ip_y[ip_y.size() - 1] - src.rows / 2))
			{
				ip_y.erase(ip_y.begin());
			}
			else
			{
				ip_y.pop_back();
			}
		}
		for (int i = 0; i < ip_y.size(); i++)
		{
			cout << ip_y[i] << endl;
			Point pt1, pt2;
			pt1.x = -1000;
			pt1.y = ip_y[i];
			pt2.x = 1000;
			pt2.y = ip_y[i];
			line(frame, pt1, pt2, Scalar(0, 255, 0), 1, CV_AA);
		}

		imshow("this is you, smile! :)", frame);
		if (waitKey(10) == 27) break; // stop capturing by pressing ESC 
	}
	// the camera will be closed automatically upon exit
	// cap.close();
	//bgframe = imread("emptyboard4.jpg");
	//imwrite("emptyboard7.bmp", bgframe);
	//imshow("gridlines", frame);

	Mat finishedFrame;
	for (;;)
	{
		cap >> finishedFrame;
		if (finishedFrame.empty()) break; // end of video stream
								  //imwrite("emptyboard2.jpg", frame);

		Mat temp = finishedFrame.clone();
		addWeighted(temp, 0.5, bgframe, 0.5, 0, temp);
		imshow("this is you, smile! :)", temp);
		if (waitKey(10) == 27) break; // stop capturing by pressing ESC 
	}

	finishedFrame = imread("stones3.jpg");
	//imwrite("stones5.bmp", finishedFrame);

	// Global variables
	Mat frame1, frame2; //current frame
	Mat fgMaskMOG2; //fg mask fg mask generated by MOG method
	Ptr<BackgroundSubtractor> pMOG2; //MOG2 Background subtractor

	pMOG2 = createBackgroundSubtractorMOG2();

	frame1 = bgframe.clone();
	cvtColor(frame1, frame1, CV_BGR2GRAY);
	GaussianBlur(frame1, frame1, Size(5, 5), 0, 0);
	//	adaptiveThreshold(frame1, frame1, 255, ADAPTIVE_THRESH_GAUSSIAN_C, CV_THRESH_BINARY, 15, 11);
	imshow("emptyboard1", frame1);

	frame2 = finishedFrame.clone();
	cvtColor(frame2, frame2, CV_BGR2GRAY);
	GaussianBlur(frame2, frame2, Size(5, 5), 0, 0);
	//	adaptiveThreshold(frame2, frame2, 255, ADAPTIVE_THRESH_GAUSSIAN_C, CV_THRESH_BINARY, 15, 11);
	imshow("result1", frame2);

	//update the background model
	pMOG2->apply(frame1, fgMaskMOG2);
	//update the background model
	pMOG2->apply(frame2, fgMaskMOG2);

	medianBlur(fgMaskMOG2, fgMaskMOG2, 5);
	Mat displayMask = fgMaskMOG2.clone();
	for (int i = 0; i < 19; i++)
	{
		Point pt1, pt2;
		pt1.x = ip_x[i];
		pt1.y = 1000;
		pt2.x = ip_x[i];
		pt2.y = -1000;
		line(displayMask, pt1, pt2, Scalar(0, 255, 0), 1, CV_AA);
		pt1.x = -1000;
		pt1.y = ip_y[i];
		pt2.x = 1000;
		pt2.y = ip_y[i];
		line(displayMask, pt1, pt2, Scalar(0, 255, 0), 1, CV_AA);
	}

	imshow("FG Mask MOG2", displayMask);

	//initialize board model
	GoBoard board = GoBoard();

	Mat finishedFrame_G = finishedFrame.clone();
	cvtColor(finishedFrame_G, finishedFrame_G, CV_BGR2GRAY);
	//detect stones and popultate gridTile vector
	for (int i = 0; i < ip_x.size(); i++)
	{
		for (int j = 0; j < ip_y.size(); j++)
		{
			int xBoundLeft = static_cast<int>( ip_x[i] - 3);
			int xBoundRight = xBoundLeft + 6;
			int yBoundUp = static_cast<int>(ip_y[j] - 3);
			int yBoundDown = yBoundUp + 6;
			int mean = 0;
			for (int x = xBoundLeft; x < xBoundRight; x++)
			{
				for (int y = yBoundUp; y < yBoundDown; y++)
				{
					if (y < 0 || y > fgMaskMOG2.rows || x < 0 || x > fgMaskMOG2.cols)
					{
						continue;
					}
					mean += fgMaskMOG2.at<uchar>(y, x);
				}
			}
			mean /= 49;
			if (mean > 25)
			{
				int blueMean = 0;
				int greenMean = 0;
				int redMean = 0;
				//mean = 0;
				for (int x = xBoundLeft-5; x < xBoundRight+5; x++)
				{
					for (int y = yBoundUp-5; y < yBoundDown+5; y++)
					{
						if (y < 0 || y > fgMaskMOG2.rows || x < 0 || x > fgMaskMOG2.cols)
						{
							continue;
						}
						Vec3b intensity = finishedFrame.at<Vec3b>(y, x);
						blueMean += intensity.val[0];
						greenMean += intensity.val[1];
						redMean += intensity.val[2];
					}
				}
				blueMean /= 289;
				greenMean /= 289;
				redMean /= 289;
				cout << "the BGR mean at x = " << i << ", y = " << j << "is " << blueMean << "," << greenMean << "," << redMean << endl;
				if (blueMean < 100 && greenMean < 100 && redMean < 100)
				{
					board.placeStone(TileType::BlackStone, i + 1, j + 1);
					//cout << "the BGR mean at x = " << i << ", y = " << j << "is " << blueMean << "," <<greenMean << "," << redMean << endl;
				}
				else/* if (blueMean > 100 && greenMean > 100 && redMean > 100 && (redMean - (blueMean+greenMean)/2 < 10))*/
				{
					int blackPixels = 0;
					for (int x = xBoundLeft; x < xBoundRight; x++)
					{
						for (int y = yBoundUp; y < yBoundDown; y++)
						{
							if (y < 0 || y > finishedFrame.rows || x < 0 || x > finishedFrame.cols)
							{
								continue;
							}
							Vec3b c = finishedFrame.at<Vec3b>(y, x);
							if ((c[0] + c[1] + c[2]) / 3 < 75)
							{
								blackPixels++;
							}
						}
					}
					if (blackPixels <= 5)
					{
						board.placeStone(TileType::WhiteStone, i + 1, j + 1);
					}
					//cout << "the BGR mean at x = " << i << ", y = " << j << "is " << blueMean << "," << greenMean << "," << redMean << endl;
				}
			}
		}
	}

	//Display detected stones
	Mat displayFrame = bgframe.clone();
	for (int i = 0; i < 19; i++)
	{
		Point pt1, pt2;
		pt1.x = ip_x[i];
		pt1.y = 1000;
		pt2.x = ip_x[i];
		pt2.y = -1000;
		line(displayFrame, pt1, pt2, Scalar(0, 255, 0), 1, CV_AA);
		pt1.x = -1000;
		pt1.y = ip_y[i];
		pt2.x = 1000;
		pt2.y = ip_y[i];
		line(displayFrame, pt1, pt2, Scalar(0, 255, 0), 1, CV_AA);
		for (int j = 0; j < 19; j++)
		{
			TileType stone = board.getTileAt(i+1, j+1)->getContents();
			if (stone == TileType::WhiteStone || stone == TileType::BlackStone)
			{
				Scalar colour = Scalar(0, 0, 0);
				if (stone == TileType::WhiteStone)
				{
					colour = Scalar(255, 255, 255);
				}
				circle(displayFrame, Point(ip_x[i], ip_y[j]), 10, colour, -1);
			}

		}
	}
	imshow("Detected stones", displayFrame);

	auto scores = board.calculateScores();
	cout << "Black scored " << scores.blackScore << " points and enclosed " << scores.blackTotalArea << " tiles.\n";
	cout << "White scored " << scores.whiteScore << " points and enclosed " << scores.whiteTotalArea << " tiles.\n";
	if (scores.blackScore > scores.whiteScore)
	{
		cout << "Black wins!\n";
	}
	else if (scores.blackScore < scores.whiteScore)
	{
		cout << "White wins!\n";
	}
	else
	{
		cout << "There was a tie!\n";
	}

	waitKey(0);
	return 0; 
}

